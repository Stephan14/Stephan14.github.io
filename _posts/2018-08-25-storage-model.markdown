---
layout:     post
title:      "存储模型"
subtitle:   "程序运行的相关技术"
date:       2018-08-25 17:44:00
author:     "邹盛富"
header-img: "img/milky-way-2695569_1920.jpg"
tags:
    - 操作系统
---

## 存在的问题

如何把多个进程的地址空间映射到物理地址空间中，合理分配使用内存

## 地址重定位

进程中的地址不是进程的最终物理地址，因为其在运行之前没有被加载到物理内存中，所以不能确定其最终的物理地址。因此需要地址重定位**将进程中的地址空间中的逻辑地址转化成运行时可以直接寻址的物理地址**。

### 静态重定位
当程序加载到内存中时，一次行实现逻辑地址到物理地址的转换，这样在执行过程中可以直接去内存中寻址相应的数据。

### 动态重定位
程序加载到内存中时不改变逻辑地址，在程序执行时逐条指令完成地址转换。

### 动态重定位实现

![](http://res.cloudinary.com/bytedance14/image/upload/v1535194691/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-08-25_%E4%B8%8B%E5%8D%886.57.17.png)

## 物理内存

### 内存划分
- 等长划分：把物理内存划分成大小相等的区域
- 不等长划分：物理内存被分配成大小不相等的内存区域

### 内存管理方法
- 位图：对于等长划分，每个分配单元对应位图中的一位
- 空闲区表、已分配区表：对于不等长分配，表中每一项记录空闲区(或已分配区)的起始地址、长度、标志
- 空闲区链表

## 内存分配算法
- 首次适配：在空闲区表中找到第一个满足进程要求的空闲区
- 下次适配：从下次找到的空闲区处接着查找
- 最佳适配：查找整个空闲表，找到能够满足进程要求的最小空闲区
- 最差适配：查找整个空闲表，找到能够满足进程要求的最大空闲区，将该空闲区分成两部分,一部分分配给该进程使用，另一个部分作为一个新的空闲区

## 内存回收算法
当某一块内存归还之后，前后空闲区合并并修改空闲区表

- 上相邻
- 下相邻
- 上下相邻
- 上下都不相邻

## 伙伴系统

一种经典的内存分配方案

### 主要思想
将内存按照2的幂次进行划分，组成若干空闲块链表，查找该链表找到能满足的最佳匹配块

### 算法
1. 将整个可用内存空间看做一块：2^U
2. 假设进程申请的空间大小为s,如果满足2^(U-1)< s < 2^U,则分配整个块，否则，将块划分为两个大小相等的伙伴，大小为2^(U-1)
3. 一直划分下去，直到产生大于或等于s的最小块

### 例子
![](http://res.cloudinary.com/bytedance14/image/upload/v1535268029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-08-26_%E4%B8%8B%E5%8D%883.18.54.png)

## 基本内存管理方案

### 单一连续区域

一段时间内只有一个进程在内存中

#### 优点
- 简单

#### 缺点
- 内存利用率低

### 固定分区
- 把内存空间分成若干区域，称为分区
- 每个分区大小可以相同也可以不同
- 分区大小确定后固定不变
- 每个分区装且只装一个进程

#### 例子
![](http://res.cloudinary.com/bytedance14/image/upload/v1535274718/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-08-26_%E4%B8%8B%E5%8D%885.11.05.png)

### 可变分区
根据进程的需要把内存空闲空间分割出一个分区，分配给该进程，剩余部分成为新的空闲区域。

#### 缺点
- 出现外碎片，大致内存利用率下降
        紧缩技术：将所有小的空闲区合并为较大的空闲区，但是需要考虑系统开销和移动的时机

以上三种方式都是进程整个进入内存中的连续内存区域，下面三种方式是进程进入内存的若干区域并且不连续的。

### 页式存储管理方案

#### 设计思想
- 用户地址空间被划分成大小相等的部分，称为页
- 物理地址空间按照相同的大小被划分成大小相等的区域，被称为页帧

#### 逻辑地址划分
![](http://res.cloudinary.com/bytedance14/image/upload/v1535276233/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-08-26_%E4%B8%8B%E5%8D%885.36.18.png)

#### 内存分配

以页为单位进行分配，按照进程需要的页数来分配
![](http://res.cloudinary.com/bytedance14/image/upload/v1535276689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-08-26_%E4%B8%8B%E5%8D%885.43.58.png)
- 页表记录了逻辑页号与页框号的对应关系
- 每个进程一个页表，存放在内存中

#### 地址转换
CPU取到逻辑地址，硬件自动划分为页号和页面地址，用页号查找页表得到页框号，再与页内偏移拼接成物理地址。

#### 缺点
- 可能引起内碎片问题

### 段式管理方案

#### 设计思想
- 用户地址空间按照程序自身逻辑关系划分为若干个程序段，每个程序段都有一个段名
- 内存地址空间被动态划分成若干长度不相同的区域，被称为物理段

#### 内存分配
以段为单位进行分配，每段在内存中占据连续空间，各端之间可以不相邻


#### 逻辑地址划分
由段号和段内地址组成，但是段号不是自动划分的，需要显示给出。


#### 内存分配
![](http://res.cloudinary.com/bytedance14/image/upload/v1535282835/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-08-26_%E4%B8%8B%E5%8D%887.26.32.png)
- 段表记录了段号、段首地址和段长度之间关系
- 每个进程一个段表存放在内存中

#### 地址转换
CPU取到逻辑地址，用段号查段表，得到该段在内存的起始地址，再与段内偏移计算成物理地址。


## 交换技术
解决在较小的内存空间中运行较大的进程问题。
- 内存紧缩技术
- 覆盖技术
- 交换技术
- 虚拟存储技术

### 覆盖技术
- 按照自身逻辑结构，不会同时执行的程序段共享同一块内存区域
- 程序各个模块之间有明确的调用结构

### 交换技术
内存紧张时，系统将进程中某些进程暂时移到外存中，把外存中某些进程换进内存中，占据之前所占用的区域。

#### 存在的问题
1. 交换的内容：运行时创建或者修改的内容：堆、栈
2. 交换到磁盘上的位置：系统指定一块特殊的磁盘区，不经过文件系统，由操作系统使用底层的读写操作对其进行高效访问
3. 何时发生交换：进程很少使用或者不用；内存空间不够用
4. 交换的进程：不应换出处于等待I/O状态的进程
